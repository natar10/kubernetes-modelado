\section{Conclusiones y Posibles Mejoras}

\subsection{Sobre el modelado}

El objetivo principal de este trabajo ha sido modelar una plataforma de aplicaciones distribuidas
partiendo de un problema real: la gestión de eventos y torneos para comunidades de juegos de cartas.
Para ello, se siguió un proceso que abarcó desde la identificación de requisitos hasta la
implementación de un prototipo funcional.

\subsection{Qué se puede esperar del sistema}

\subsubsection{Fortalezas}
\begin{itemize}
    \item \textbf{Trazabilidad}: Cada componente del prototipo responde a uno o más requisitos
    identificados en la fase de modelado.
    \item \textbf{Reproducibilidad}: El sistema puede desplegarse de forma idéntica en cualquier
    cluster Kubernetes gracias a la naturaleza declarativa de los manifiestos.
    \item \textbf{Escalabilidad}: Cada componente puede escalar horizontalmente de forma
    independiente modificando el campo \texttt{replicas}.
    \item \textbf{Coordinación asíncrona}: RabbitMQ permite procesar inscripciones en orden
    de llegada sin bloquear el flujo principal de peticiones.
\end{itemize}

\subsection{Posibles Mejoras}

\begin{enumerate}\item \textbf{Observabilidad completa}: Prometheus + Grafana para métricas, ELK para logs,
    Jaeger para tracing distribuido.
    \item \textbf{TLS/HTTPS}: Usar cert-manager con Let's Encrypt para certificados automáticos.
    \item \textbf{CI/CD}: Pipeline con GitHub Actions para despliegue automatizado.
    \item \textbf{GitOps}: Usar ArgoCD o Flux para gestión declarativa del cluster.
    \item \textbf{Caché}: Se podría añadir Redis para mejorar el rendimiento de lecturas frecuentes.
    \item \textbf{Balanceo de carga avanzado}: Configurar NGINX con reglas de enrutamiento más sofisticadas.
\end{enumerate}

\subsection{Conclusión}

Este trabajo demuestra cómo el proceso de modelado de una plataforma distribuida permite
pasar de un problema concreto a una arquitectura bien definida y desplegable. A través de
la definición de requisitos, la elaboración de diagramas SysML/UML y la asignación de
tecnologías, se obtuvo una visión clara del sistema antes de escribir una sola línea de
configuración.

La implementación del prototipo en Kubernetes validó que las decisiones tomadas durante
el modelado son viables: la separación en microservicios, la coordinación asíncrona
mediante RabbitMQ, la autenticación centralizada con Keycloak y la orquestación declarativa
funcionan de forma conjunta. Aunque el prototipo utiliza servicios mock, la infraestructura
está preparada para evolucionar hacia un sistema con lógica de negocio real.

Como aprendizaje principal, este proyecto nos ha permitido comprender la importancia de
modelar antes de implementar: los diagramas no son solo documentación, sino herramientas
que guían las decisiones de diseño y facilitan la comunicación entre los miembros del equipo.
